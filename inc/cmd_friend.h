/**
 * @mainpage
 * 
 * # CMD_Friend - The Command line friend library!
 * 
 * Simple command line arguments parser for C and C++ applications.
 * 
 * This library is made for C and C++ programs to parse command line options in the easiest way possible.
 * Based heavily on the argp library of the GNU project.
 * 
 * TL;DR: Sources and include files are in [modules/cmd_friend](./modules/cmd_friend). Compile static .a and dynamic .dll libraries are in [modules/cmd_friend/lib](./modules/cmd_friend/lib). 
 * Make a cmdf_option array for your options, make a parse function, call the main cdmf_parse_options() function.
 * 
 * Created by: João Peterson Scheffer - 2020.
 * Version: v1.2
 * 
 * Documentation generated by Doxygen, saved in [docs](./docs) folder and hosted on [Github pages](https://joao-peterson.github.io/CMD-Friend/), click to redirect.
 * 
 * ### Compilation
 * 
 * To compile this library simply compile the source with the header, no dependencies.
 * Arquive if static compile or compile as shared and you can use in your projects, or as i like, compile the source into a object
 * and link it with your main application.
 * 
 * ### Use
 * 
 * To use, first you can define strings with default program information in you main function:
 * ```c
 *     set_cmdf_default_info_usage("Usage: [-w,-o,-f] for project or [-M,-m] for module [FILEPATH] [OPTIONS...]");
 *     set_cmdf_default_info_version("v1.1 - 17/08/2020");
 *     set_cmdf_default_info_contact_info("Repo: https://github.com/Joao-Peterson/CMD-Friend - Email: joco_zx@hotmail.com");
 * ```
 * Then make a array of options in your main aplication outside main(). Eg:
 * 
 * ```c
 *      cmdf_option options[] = 
 *      {
 *          {"where",   'w', 0,                                             1, "Where to create the project"},
 *          {"file",    'f', OPTION_ALIAS },
 *          {"tags",    't', OPTION_OPTIONAL,                              -1, "Tags to put in"},
 *          {"verbose", 'v', OPTION_OPTIONAL | OPTION_NO_LONG_KEY,          0, "Verbose mode"},
 *          {"Wall",    'W', OPTION_OPTIONAL,                               0, "Wall error mode"},
 *          {"vscode",   VSCODE_KEY, OPTION_OPTIONAL | OPTION_NO_CHAR_KEY,  0, "Visual studio code .vscode folder with .json configuration files"},
 *          {0}
 *      };
 * ```
 * 
 * Define a struct of your flavor that hold flags and variables associated with your options, these will be used later in your main aplication. Eg:
 * 
 * ```c
 *      struct arguments_info
 *      {
 *          char *filepath_project;         // filepath to generte template project
 *          int tags;                       // int that has bitwise tags
 *          int verbose_enable;             // flag that indicates if the program will print to console
 *          int wall_enable;                // flag that indicates if the program will use wall commands
 *          int generate_vscode_folder;     // flag that indicates to generate a vscode folder with .json configuration files
 *      };
 * ```
 * 
 * Then define a parser function for your options. It should contain a cast to your custom struct and
 * a switch case with cases for your options. Eg:
 * 
 * ```c 
 *      int parse_options(char key, char *arg, int arg_pos, void *extern_user_variables_struct)
 *      {
 *          struct arguments_info *myvariables = (struct arguments_info*)extern_user_variables_struct; // retrieving custom struct by casting
 *          long int tag_bit;
 *      
 *          switch (key)
 *          {
 *              case 'w': case 'f':                             // --where, --output, --folder 
 *                  myvariables->filepath_project = arg;
 *                  printf("[ARG] Argument \"%s\" for key -%c .\n",arg,key);
 *                  break;
 *      
 *              case 't':                                       // --tags
 *                  if((tag_bit = strtol(arg, NULL, 10)) > INT_MAX)
 *                  {
 *                      printf("[ARG] Argument \"%s\" for key -%c needs to be smaller than %ld.\n",arg,key,INT_MAX);
 *                      exit(1);
 *                  }
 *                  else
 *                      myvariables->tags |= tag_bit;                
 *                  
 *                  printf("[ARG] Number \"%X\" for key -%c .\n",tag_bit,key);
 *                  
 *                  break;
 *      
 *              case 'v':                                       // --verbose
 *                  printf("[ARG] verbose\n");
 *                  myvariables->verbose_enable = 1;
 *                  break;
 *              
 *              case 'W':                                       // --Wall
 *                  myvariables->wall_enable = 1;
 *                  printf("[ARG] Wall\n");
 *                  break;
 *      
 *              case VSCODE_KEY:                                // --vscode
 *                  myvariables->generate_vscode_folder = 1;
 *                  printf("[ARG] VSCODE!\n");
 *                  break;
 *      
 *              case 0:                                         
 *                  printf("[ARG] Case 0 hapenned! Key: -%c Arg: %s\n",key,arg);
 *                  break;                          
 *      
 *              default: 
 *                  printf("[ARG] Case default hapenned! Key: -%c Arg: %s\n",key,arg);
 *                  break;
 *          }
 *      
 *          return 0;
 *      }
 * ``` 
 * 
 * Finally you can call the main library function and then use your processed flags and variables in your custom struct
 * as you desire. Eg:
 * 
 * ```c
 *      cdmf_parse_options(options, parse_options, argc, argv, PARSER_FLAG_PRINT_ERRORS_STDOUT | PARSER_FLAG_USE_PREDEFINED_OPTIONS | PARSER_FLAG_DONT_IGNORE_NON_REGISTERED_OPTIONS, &myvars);
 * ```
 */ 


/**
 * @file cmd_friend.h
 * 
 * CMD_Friend - The Command line friend library!
 * 
 * This library is made for C and C++ programs to parse command line options in the easiest way possible.
 * Based heavily on the argp library of the GNU project.
 * 
 * Created by: João Peterson Scheffer - 2020.
 * 
 * This is the header file, please don't modify, except when stated in documentation.
 * 
 * Refer to this header as means to use the library and get informations about the variables and functions.
 * 
 */


#ifdef __cplusplus  
extern "C" { 
#endif 


#ifndef __CMD_FRIEND
#define __CMD_FRIEND

/* Includes and dependencies */

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>


/* -------------------------------------------- Definitions ---------------------------------------------------- */


#define __INFO_KEY       123     // default info option key
#define __VERSION_KEY    124     // default version option key
#define __HELP_KEY       125     // default help option key, in case of the 'h' key be desired i suggest using 125 as a key instead

#define MAX_CMD_ARGUMENTS 1000 // maximum number of arguments to be parsed


/* -------------------------------------------- Enumerators ---------------------------------------------------- */


/**
 * @brief Parameters for registering cmd options.
 * 
 * To apply multiple options, just use the or bitwise operator pipe "|".
 */
typedef enum
{
    OPTION_ALIAS            = 0x01,   /**< Specifies that this option is an alias of the above option */
    OPTION_OPTIONAL         = 0x02,   /**< This option is not trivial for the program */
    OPTION_NO_CHAR_KEY      = 0x04,   /**< This option can't be called by a alphabetical key, just the long version */
    OPTION_NO_LONG_KEY      = 0x08,   /**< This option can't be called by the long version, just the single char key */
    OPTION_HIDDEN           = 0x10    /**< This option doesn't appear on help menu */
}OPTIONS_Typedef;


/**
 * @brief Flags for when calling cmdf_parse_options.
 * 
 * To apply multiple flags, just use the or bitwise operator "OR" ("|").
 */
typedef enum
{
    //PARSER_FLAG_NOT_EXIT_ON_ERROR                   = 0x01,     /**< When an exception occurs don't exit program */
    PARSER_FLAG_PRINT_ERRORS_STDOUT                 = 0x02,     /**< Print error messages to stdout */
    PARSER_FLAG_PRINT_ERRORS_STDERR                 = 0x04,     /**< Print error messages to stderr */
    PARSER_FLAG_DONT_IGNORE_NON_REGISTERED_OPTIONS  = 0x08,     /**< Extra options given by the user do not are discarted, an error will be trown */
    PARSER_FLAG_USE_PREDEFINED_OPTIONS              = 0x10      /**< Create automatic options, by default: --help (-h), --info (-i), --version (-v) */
}PARSER_FLAGS_Typedef;


/* -------------------------------------------- Structures and typedefs----------------------------------------- */


/**
 * @brief Typedef from user parse option function.
 * The "cdmf_parse_options" function will call the user defined function to handle actions as desired.
 * Each call will have a key and argument, where each argument must have be assigned to only one key.
 * @param key: Receives the char key of the option.
 * @param arg: Receives the argument passed to that option.
 * @param arg_pos: The command line argument index where the user inserted the argumment.
 * @param arg_pos: Opaque pointer to user define struct in main program, containing variables that can be acesses inside this function. (Cast is necessary!).
 */
typedef int (*option_parse_function)(char key, char *arg, int arg_pos, void *extern_user_variables_struct);


/**
 * @brief defines a single option in command line.
 * 
 * An array of this struct is used when registering new entries using the default constructor
 * making the process of adding more options more easy.
 * 
 * @note The last member must be always 0, just as a string is a array of char that ends in 0.
 */
typedef struct
{
    char *long_name;                                /**< The name of the option, also used when calling with "--" */
    char key;                                       /**< Character key correponding to the name, often just the first letter. Called with "-". If the option doesn't need a alphabetical key then specify a integer value ">0" and "!=(ASCII letter)" as means to identification */
    OPTIONS_Typedef parameters;                     /**< Parameters to enhance functionality */
    int argq;                                       /**< The number of arguments that this option takes, can be >0, if 0 then expects none, if -1 accepts any quantity but at least one */
    char *description;                              /**< Small description of the option*/
}cmdf_option;


/* -------------------------------------------- Public prototypes ---------------------------------------------- */


/**
 * @brief Set default value of cmdf_default_info_usage.
 * @param info_string: Const string with desired information.
 */
void set_cmdf_default_info_usage(const char *info_string);


/**
 * @brief Set default value of cmdf_default_info_version.
 * @param info_string: Const string with desired information.
 */
void set_cmdf_default_info_version(const char *info_string);


/**
 * @brief Set default value of cmdf_default_info_contact.
 * @param info_string: Const string with desired information.
 */
void set_cmdf_default_info_contact_info(const char *info_string);


/**
 * @brief Main library function, used to parse options in main program.
 * The "cdmf_parse_options" function will call the user defined function to handle actions as desired.
 * Each call will have a key and argument, where each argument must have be assigned to only one key.
 * @param registered_options: Receives pointer to struct "cmdf_option" array that shall contain user define options.
 * @param parse_function: User defined parse function pointer.
 * @param argc: Main function parameter containing number of passed parameters in command line.
 * @param argv: Main function parameter containing the array of string containing the actual parameters.
 * @param flags: Flags used to customize the function "cdmf_parse_options" behavior, flags shall be located on "PARSER_FLAGS_Typedef" enumerator.
 * @param extern_user_variables_struct: Opaque pointer to user define struct in main program, used to be accessed in the also user define parser function.
 * @return Returns a integer number correponding to a error code, 0 if no error occurred. Note: NO ERROR CODE IMPLEMENTED AT THIS VERSION.
 */
int cdmf_parse_options(cmdf_option *registered_options, option_parse_function parse_function, int argc, char **argv, PARSER_FLAGS_Typedef flags, void *extern_user_variables_struct);


#endif


#ifdef __cplusplus 
} 
#endif 